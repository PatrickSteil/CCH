# Customizable Contraction Hierarchies

## Shortest Path
In graph theory, the shortest path problem involves finding the most efficient path between two vertices (nodes) in a graph. The "shortest path" is typically defined by the minimum sum of weights associated with the edges connecting the vertices. There are various algorithms to solve this problem, with Dijkstra's algorithm and the Bellman-Ford algorithm being two common examples.
## Real-World Road Navigation Systems
In the context of road navigation systems, road networks can be represented as graphs, where intersections are nodes and roads are edges. Each edge has a weight associated with it, representing factors like distance, travel time, or other considerations.
The shortest path problem is crucial in road navigation for determining the optimal route between a starting point and a destination. The goal is to find the path with the minimum travel time, distance, or some other metric, depending on the user's preferences or constraints.
Modern road navigation systems use real-time data to provide accurate and up-to-date information. This includes traffic conditions, road closures, accidents, and more. The shortest path algorithm needs to adapt dynamically to these changes, recalculating routes to help users avoid congested or blocked areas.

In summary, the shortest path problem is at the core of road navigation systems, enabling them to efficiently guide users through complex road networks while considering real-time information and various user preferences. This application showcases the practical importance of graph theory in optimizing routes for everyday travel.

## Customizable Contraction Hierarchies
One algorithm, to efficiently handle the requirements of being able to dynamically adapt to changing edge weights while still answering queries in under a millisecond, is the Customizable Contraction Hierarchies (CCH) algorithm. The core idea is based on the Contraction Hierarchies (CH) algorithm, which _contracts_ all vertices in a specific importance order (based on shortest paths). The idea of defining a total ranking of vertices, is useful for the query algorithm, where, starting from the given source and target, you relax only edges to "more" important neighbors. Since this "upwards" search space is typically much smaller, queries are much faster than plain (bidirectional) Dijkstra.
One major drawback, however, is the inherent _metric-dependent_ contraction and, thus, the build hierarchy. Hence, changing edge weights can only be handled by completely rebuilding the hierarchy. The CCH algorithm, however, can deal with changing edges weights by changing the concept of "importance" by using [nested dissection ordering](https://en.wikipedia.org/wiki/Nested_dissection). All vertices, w.r.t. the computed nested dissection ordering, are then contracted, and a [chordal graph](https://en.wikipedia.org/wiki/Chordal_graph) is built. Note that this "preprocessing" phase is done _metric-independently_. To incorporate edge weights, the CCH algorithm performs two kinds of "customizations": "basic and "perfect". The basic customization guarantees, that all introduced shortcuts are "real" shortcuts, i.e., their edge weight respects the shortest path distances passing via the corresponding contracted vertex. But since the total number of edges and shortcuts in the chordal graph is still too large, the perfect customization removes edges and shortcuts that do not occur in _any_ shortest path. Note that both customization steps can be performed in just a few seconds, allowing for real-world use. 
